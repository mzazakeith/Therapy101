import _extends from 'babel-runtime/helpers/extends';
import _defineProperty from 'babel-runtime/helpers/defineProperty';
import _toConsumableArray from 'babel-runtime/helpers/toConsumableArray';
import * as React from 'react';
import classNames from 'classnames';
import * as allIcons from '@ant-design/icons';
import ReactIcon from '@ant-design/icons-react';
import createFromIconfontCN from './IconFont';
import { svgBaseProps, withThemeSuffix, removeTypeTheme, getThemeFromTypeName } from './utils';
import warning from '../_util/warning';
import { getTwoToneColor, setTwoToneColor } from './twoTonePrimaryColor';
// Initial setting
ReactIcon.add.apply(ReactIcon, _toConsumableArray(Object.keys(allIcons).map(function (key) {
    return allIcons[key];
})));
setTwoToneColor('#1890ff');
var Icon = function Icon(props) {
    var _classNames;

    var title = props.title,
        className = props.className,
        onClick = props.onClick,
        style = props.style,
        type = props.type,
        Component = props.component,
        viewBox = props.viewBox,
        spin = props.spin,
        children = props.children,
        theme = props.theme,
        twoToneColor = props.twoToneColor;

    warning(Boolean(type || Component || children), 'Icon should have `type` prop or `component` prop or `children`.');
    var classString = classNames((_classNames = {}, _defineProperty(_classNames, 'anticon', true), _defineProperty(_classNames, 'anticon-' + type, Boolean(type)), _classNames), className);
    var svgClassString = classNames(_defineProperty({}, 'anticon-spin', !!spin || type === 'loading'));
    // component > children > type
    if (Component) {
        var innerSvgProps = _extends({}, svgBaseProps, { className: svgClassString, viewBox: viewBox });
        if (!viewBox) {
            delete innerSvgProps.viewBox;
        }
        return React.createElement(
            'i',
            { className: classString, title: title, style: style, onClick: onClick },
            React.createElement(
                Component,
                innerSvgProps,
                children
            )
        );
    }
    if (children) {
        warning(Boolean(viewBox) || React.Children.count(children) === 1 && React.Children.only(children).type === 'use', 'Make sure that you provide correct `viewBox`' + ' prop (default `0 0 1024 1024`) to the icon.');
        var _innerSvgProps = _extends({}, svgBaseProps, { className: svgClassString });
        return React.createElement(
            'i',
            { className: classString, title: title, style: style, onClick: onClick },
            React.createElement(
                'svg',
                _extends({}, _innerSvgProps, { viewBox: viewBox }),
                children
            )
        );
    }
    if (typeof type === 'string') {
        var computedType = type;
        if (theme) {
            var alreadyHaveTheme = getThemeFromTypeName(type);
            warning(!alreadyHaveTheme, 'This icon already has a theme \'' + alreadyHaveTheme + '\'.' + (' The prop \'theme\' ' + theme + ' will be ignored.'));
        }
        computedType = withThemeSuffix(removeTypeTheme(type), theme || 'outlined');
        return React.createElement(
            'i',
            { className: classString, title: title, style: style, onClick: onClick },
            React.createElement(ReactIcon, { className: svgClassString, type: computedType, primaryColor: twoToneColor })
        );
    }
    return React.createElement('i', { className: classString, title: title, style: style, onClick: onClick });
};
Icon.displayName = 'Icon';
Icon.createFromIconfontCN = createFromIconfontCN;
Icon.getTwoToneColor = getTwoToneColor;
Icon.setTwoToneColor = setTwoToneColor;
export default Icon;